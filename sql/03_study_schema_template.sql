--   -------------------------------------------------- 
--   Generated by Enterprise Architect Version 7.5.843
--   Created On : Wednesday, 01 April, 2009 
--   DBMS       : Oracle 
--   -------------------------------------------------- 

CREATE SEQUENCE ${projectName}.PAV_GROUP_SEQUENCE start with 100;
CREATE SEQUENCE ${projectName}.PATIENT_ATTRIB_VAL_SEQUENCE start with 1000;
CREATE SEQUENCE ${projectName}.BIOSPECIMEN_VALUE_SEQUENCE start with 1000;

--  Create Tables 

CREATE TABLE ${projectName}.SCHEMA_CONFIGURATION (
schema_version number(3,0) NOT NULL,
schema_date date not null,
schema_notes varchar(2000)
);

CREATE TABLE ${projectName}.BIOSPECIMEN
(
	biospecimen_id         NUMBER(10) NOT NULL,
	class                  VARCHAR2(20) NOT NULL,    --  SAMPLE,EXTRACT,LABELED_EXTRACT 
	name                   VARCHAR2(50) NOT NULL,    --  a unique name, within the datasource, for the biospecimen 
	patient_id             NUMBER(10) NOT NULL,    --  whch patient the biospecimen comes from 
	biospecimen_parent_id  NUMBER(10) NULL,    --  which biospecimen this biospecimen comes from.  For example, an EXTRACT comes from a SAMPLE, while a LABELED_EXTRACT comes from an EXTRACT. 
	protocol_id            NUMBER(4) NULL,    --  the method by which the biospecimen was derived from its parent. 
	diseased               NUMBER(1) NOT NULL,    --  1=derived from diseased or cancerous material 0=not derived from diseased or cancerous material. 
	insert_user            VARCHAR(20) NOT NULL,
	insert_date            DATE NOT NULL,
	insert_method          VARCHAR2(20) NOT NULL,
	attribute_timepoint_id number(10) default 0 NOT NULL,
	age_at_event 		   number(3,1)
);

COMMENT ON COLUMN ${projectName}.BIOSPECIMEN.class                  IS 'SAMPLE,EXTRACT,LABELED_EXTRACT';
COMMENT ON COLUMN ${projectName}.BIOSPECIMEN.name                   IS 'a unique name, within the datasource, for the biospecimen';
COMMENT ON COLUMN ${projectName}.BIOSPECIMEN.patient_id             IS 'whch patient the biospecimen comes from';
COMMENT ON COLUMN ${projectName}.BIOSPECIMEN.biospecimen_parent_id  IS 'which biospecimen this biospecimen comes from.  For example, an EXTRACT comes from a SAMPLE, while a LABELED_EXTRACT comes from an EXTRACT.';
COMMENT ON COLUMN ${projectName}.BIOSPECIMEN.protocol_id            IS 'the method by which the biospecimen was derived from its parent.';
COMMENT ON COLUMN ${projectName}.BIOSPECIMEN.diseased               IS '1=derived from diseased or cancerous material 0=not derived from diseased or cancerous material.';

CREATE TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE
(
	patient_attribute_value_id       NUMBER(10) NOT NULL,    --  PK 
	patient_id         NUMBER(10) NOT NULL,
	attribute_type_id  NUMBER(10) NOT NULL,
	value              VARCHAR2(100) NOT NULL,    --  To improve indexing, the actual value is stored here and any vocabulary checking takes place in the insert trigger.
        group_number NUMBER(8) NULL, 
	attribute_timepoint_id   NUMBER(10) NULL,
	age_at_event       NUMBER(3,1) NULL,    --  Age at event in years (eg  64.7) 
	insert_user        VARCHAR2(10) NOT NULL,
	insert_date        DATE NOT NULL,
	insert_method      VARCHAR2(20) NOT NULL
);

COMMENT ON TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE IS 'Relates a patient, an attribute, and the value.  If a attribute_type_id''s vocabulary flag = 1, then an insert trigger will determine if the value is in the set of appropriate values for this attribute.';
COMMENT ON COLUMN ${projectName}.PATIENT_ATTRIBUTE_VALUE.patient_attribute_value_id       IS 'PK';
COMMENT ON COLUMN ${projectName}.PATIENT_ATTRIBUTE_VALUE.value              IS 'To improve indexing, the actual value is stored here and any vocabulary checking takes place in the insert trigger.';
COMMENT ON COLUMN ${projectName}.PATIENT_ATTRIBUTE_VALUE.age_at_event       IS 'Age at event in years (eg  64.7)';
COMMENT ON COLUMN ${projectName}.PATIENT_ATTRIBUTE_VALUE.group_number IS 'sometimes attributes need to be viewed as a group, for example....';

CREATE TABLE ${projectName}.ORIGINAL_ATTRIBUTE
(
	attribute_type_id  NUMBER(10) NOT NULL,
	name               VARCHAR2(200) NOT NULL,    -- The original name of the attribute as is in the datasource, mixed-case incase the source is not case-insensitive 
	conversion_note    VARCHAR2(255) NULL    -- If the data from the original data source has been converted in any way, indicate how. 
);

COMMENT ON COLUMN ${projectName}.ORIGINAL_ATTRIBUTE.name               IS 'The original name of the attribute as is in the datasource, mixed-case incase the source is not case-insensitive';
COMMENT ON COLUMN ${projectName}.ORIGINAL_ATTRIBUTE.conversion_note    IS 'If the data from the original data source has been converted in any way, indicate how.';


CREATE TABLE ${projectName}.PATIENT
(
	patient_id               NUMBER(10) NOT NULL,    --  Unique numerical ID for a patient/participant/person.  GDOC_id not used here so that patients that overlap between data sources can easily be identified by a single GDOC_id, even after initally loading. 
	data_source_internal_id  VARCHAR2(15) NOT NULL,
	insert_user              VARCHAR2(10) NOT NULL,
	insert_date              DATE NOT NULL,
	insert_method            VARCHAR2(20) NOT NULL
);

COMMENT ON TABLE ${projectName}.PATIENT IS 'Data source specific Patient table.  Contains the data source specific patient/participant internal ID.';
COMMENT ON COLUMN ${projectName}.PATIENT.patient_id               IS 'Unique numerical ID for a patient/participant/person.  GDOC_id not used here so that patients that overlap between data sources can easily be identified by a single GDOC_id, even after initally loading.';


CREATE TABLE ${projectName}.ATTRIBUTE_TIMEPOINT
(
	attribute_timepoint_id  NUMBER(10) NOT NULL,    --  Unique internal ID for DB use only. 
	series_id         NUMBER(5) NOT NULL,    --  Unique numerical  internal ID for DB use only.   Groups related timepoints together. 
	timepoint         NUMBER(3) NOT NULL,    --  Indicates the order of the timepoints, starting with 1. 
	tag               VARCHAR2(25) NULL,    --  A textual indication of which timepoint it is. 
	insert_user       VARCHAR2(10) NOT NULL,
	insert_date       DATE NOT NULL,
	insert_method     VARCHAR2(20) NOT NULL
);

COMMENT ON TABLE ${projectName}.ATTRIBUTE_TIMEPOINT IS 'Describes a time series at the project level.  For example, "screening", "biopsy", "surgery" maybe three timepoints in a series.  Each gets a time point ID and is grouped together by the series_id.  This table could be further de-normalized, but...';
COMMENT ON COLUMN ${projectName}.ATTRIBUTE_TIMEPOINT.attribute_timepoint_id  IS 'Unique internal ID for DB use only.';
COMMENT ON COLUMN ${projectName}.ATTRIBUTE_TIMEPOINT.series_id         IS 'Unique numerical  internal ID for DB use only.   Groups related timepoints together.';
COMMENT ON COLUMN ${projectName}.ATTRIBUTE_TIMEPOINT.timepoint         IS 'Indicates the order of the timepoints, starting with 1.';
COMMENT ON COLUMN ${projectName}.ATTRIBUTE_TIMEPOINT.tag               IS 'A textual indication of which timepoint it is.';




--  Create Primary Key Constraints 
ALTER TABLE ${projectName}.SCHEMA_CONFIGURATION ADD CONSTRAINT SCHEMA_CONFIGURATION_PK PRIMARY KEY (schema_version);

ALTER TABLE ${projectName}.BIOSPECIMEN ADD CONSTRAINT BIOSPECIMEN_PK 
	PRIMARY KEY (biospecimen_id) 
  ;

ALTER TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE ADD CONSTRAINT PATIENT_ATTRIBUTE_VALUE_PK 
	PRIMARY KEY (patient_attribute_value_id) 
  ;

ALTER TABLE ${projectName}.ORIGINAL_ATTRIBUTE ADD CONSTRAINT ORIGINAL_ATTRIBUTE_PK 
	PRIMARY KEY (attribute_type_id) 
  ;

ALTER TABLE ${projectName}.PATIENT ADD CONSTRAINT PATIENT_PK 
	PRIMARY KEY (patient_id) 
  ;

ALTER TABLE ${projectName}.ATTRIBUTE_TIMEPOINT ADD CONSTRAINT ATTRIBUTE_TIMEPOINT_PK 
	PRIMARY KEY (attribute_timepoint_id) 
  ;



--  Create Indexes 

ALTER TABLE ${projectName}.BIOSPECIMEN
	ADD CONSTRAINT BIOSPECIMEN_name_AK UNIQUE (name)
  ;

ALTER TABLE ${projectName}.BIOSPECIMEN
ADD CONSTRAINT BIOSPECIMEN_class_CC CHECK (class in ('SAMPLE','EXTRACT','LABELED_EXTRACT'));

ALTER TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE
	ADD CONSTRAINT PAV_VALUE_AK1 UNIQUE (patient_id, attribute_type_id, attribute_timepoint_id)
  ;

ALTER TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE
	ADD CONSTRAINT PAV_VALUE_AK2 UNIQUE (group_number, patient_id, attribute_type_id)
  ;


ALTER TABLE ${projectName}.PATIENT
	ADD CONSTRAINT PATIENT_AK1 UNIQUE (data_source_internal_id)
  ;


--  Create Foreign Key Constraints 
ALTER TABLE ${projectName}.BIOSPECIMEN ADD CONSTRAINT BIOSPECIMEN_patient_FK 
	FOREIGN KEY (patient_id) REFERENCES ${projectName}.PATIENT (patient_id);

ALTER TABLE ${projectName}.BIOSPECIMEN ADD CONSTRAINT BIOSPECIMEN_parent_FK 
	FOREIGN KEY (biospecimen_parent_id) REFERENCES ${projectName}.BIOSPECIMEN (biospecimen_id);

ALTER TABLE ${projectName}.BIOSPECIMEN ADD CONSTRAINT BIOSPECIMEN_protocol_FK 
	FOREIGN KEY (protocol_id) REFERENCES COMMON.PROTOCOL (protocol_id);

ALTER TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE ADD CONSTRAINT PAV_patient_FK 
	FOREIGN KEY (patient_id) REFERENCES ${projectName}.PATIENT (patient_id);

ALTER TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE ADD CONSTRAINT PAV_attribute_type_FK 
	FOREIGN KEY (attribute_type_id) REFERENCES COMMON.ATTRIBUTE_TYPE (attribute_type_id);

ALTER TABLE ${projectName}.PATIENT_ATTRIBUTE_VALUE ADD CONSTRAINT PAV_timepoint_FK 
	FOREIGN KEY (attribute_timepoint_id) REFERENCES ${projectName}.ATTRIBUTE_TIMEPOINT (attribute_timepoint_id);

ALTER TABLE ${projectName}.ORIGINAL_ATTRIBUTE ADD CONSTRAINT OA_attribute_type_FK 
	FOREIGN KEY (attribute_type_id) REFERENCES COMMON.ATTRIBUTE_TYPE (attribute_type_id);

ALTER TABLE ${projectName}.biospecimen ADD CONSTRAINT BIOSPECIMEN_timpoint_fk FOREIGN KEY (attribute_timepoint_id) REFERENCES ${projectName}.attribute_timepoint;


-- Indexes
create index ${projectName}.PAV_type_value_IDX on ${projectName}.PATIENT_ATTRIBUTE_VALUE(attribute_type_id, value);





--  Create Views 
CREATE OR REPLACE VIEW ${projectName}.PATIENTS
AS
select c.gdoc_id, s.patient_id, s.data_source_internal_id
from common.patient_data_source c, ${projectName}.patient s
where s.patient_id = c.patient_id;


CREATE OR REPLACE VIEW ${projectName}.USED_ATTRIBUTES AS SELECT distinct c.attribute_type_id, o.name as original_name, o.conversion_note, c.short_name, c.long_name, c.definition, c.class, c.semantic_group, c.gdoc_preferred, c.cadsr_id, c.evs_id, c.qualitative, c.continuous, c.vocabulary, c.oracle_datatype, c.unit, c.upper_range, c.lower_range, 'PATIENT' as target
FROM (common.attribute_type c
       left outer join ${projectName}.original_attribute o
       on o.attribute_type_id = c.attribute_type_id
     ) inner join ${projectName}.patient_attribute_value v
       on v.attribute_type_id = c.attribute_type_id
WITH READ ONLY;


INSERT INTO ${projectName}.ATTRIBUTE_TIMEPOINT (
   ATTRIBUTE_TIMEPOINT_ID, SERIES_ID, TIMEPOINT, 
   TAG, INSERT_USER, INSERT_DATE, 
   INSERT_METHOD) 
VALUES (0, 0, 0,
    'DEFAULT TIMEPOINT', user, current_date, 'manual');


	CREATE SEQUENCE ${projectName}.MARRAY_FILE_COLUMN_SEQUENCE start with 1000;
	CREATE SEQUENCE ${projectName}.MARRAY_FILE_ROW_SEQUENCE start with 1000;

	CREATE TABLE ${projectName}.ATTRIBUTE_STATS
	(
		attribute_type_id  NUMBER(10) NOT NULL,    --  PK as well as FK to the common schema attribute_type table 
		nullable           NUMBER(1) NOT NULL,    --  Would  this attribute allow null values? 
		single_value       NUMBER(1) NOT NULL,    --  Do we expect a single value for this attribute.  This should coincide with attribute_type.continous, but perhaps not always. A continous attribute may only be expecting o single value in the specific study. 
		notes              VARCHAR2(255) NULL,    --  any data source specific notes on this attribute not covered in the common attribute_type table. 
		coverage           NUMBER(4,1) NULL,    --  The percent of patients who have a value for this attribute. 
		usable_coverage    NUMBER(4,1) NULL,    --  The number of patients who have a value other than stuff like UNKNOWN, N/A, NOT REPORTED, etc.  
		usable_sql         VARCHAR2(255) NULL,    --  SQL statement to determine usable_coverage, where applicable.  Oracle flavor SQL ok. 
		table_name         VARCHAR2(30) NOT NULL,    --  which table the attribute values are stored in 
		insert_user        VARCHAR2(10) NOT NULL,
		insert_date        DATE NOT NULL,
		insert_method      VARCHAR2(20) NOT NULL
	);

	COMMENT ON TABLE ${projectName}.ATTRIBUTE_STATS IS 'Notes what attribute_types are in use for a particular data source and stores usage stats.';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.attribute_type_id  IS 'PK as well as FK to the common schema attribute_type table';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.nullable           IS 'Would  this attribute allow null values?';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.single_value       IS 'Do we expect a single value for this attribute.  This should coincide with attribute_type.continous, but perhaps not always. A continous attribute may only be expecting o single value in the specific study.';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.notes              IS 'any data source specific notes on this attribute not covered in the common attribute_type table.';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.coverage           IS 'The percent of patients who have a value for this attribute.';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.usable_coverage    IS 'The number of patients who have a value other than stuff like UNKNOWN, N/A, NOT REPORTED, etc. ';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.usable_sql         IS 'SQL statement to determine usable_coverage, where applicable.  Oracle flavor SQL ok.';
	COMMENT ON COLUMN ${projectName}.ATTRIBUTE_STATS.table_name         IS 'which table the attribute values are stored in';



	CREATE TABLE ${projectName}.BIOSPECIMEN_ATTRIBUTE_VALUE
	(
		biospec_attribute_value_id  NUMBER(10) NOT NULL,
		biospecimen_id        NUMBER(10) NOT NULL,
		attribute_type_id     NUMBER(10) NOT NULL,
		value                 VARCHAR2(100) NOT NULL,
		insert_user           VARCHAR2(20) NOT NULL,
		insert_date           DATE NOT NULL,
		insert_method         VARCHAR2(20) NOT NULL
	);


	CREATE TABLE ${projectName}.mARRAY_FILE
	(
		marray_file_id             NUMBER(10) NOT NULL,
		name                       VARCHAR2(50) NOT NULL,    --  Unique name of the file within the data source.  No path information. 
		relative_path              VARCHAR2(100) NOT NULL,    --  The relative path to the file.  Relative to an environmental variable on the system. 
		size_b                     NUMBER(12) NOT NULL,    --  Size of the file in bytes. 
		file_type_id               NUMBER(3) NOT NULL,
		file_format_id             NUMBER(3) NOT NULL,
		data_level                 VARCHAR2(15) NOT NULL,    --  RAW,NORMALIZED,INTERPRETED,ROI 
		protocol_id                NUMBER(4) NULL,    --  protocol_id to get from this file from its prior file(s) 
		reporter_list_id           NUMBER(3) NULL,    --  If a NORMALIZED file, the list of reporter(set)s found in the first column.  Sometimes these are not exactly the same as the expected reporter list form the array design 
		reporter_list_as_platform  NUMBER(1) NULL,    --  convenience.  is the reporter list for this tuple the same as what is expected from the array design 
		insert_user                VARCHAR(20) NOT NULL,
		insert_date                DATE NOT NULL,
		insert_method              VARCHAR2(20) NOT NULL,
		description 			   varchar2(100)
	);

	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.name                       IS 'Unique name of the file within the data source.  No path information.';
	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.relative_path              IS 'The relative path to the file.  Relative to an environmental variable on the system.';
	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.size_b                     IS 'Size of the file in bytes.';
	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.data_level                 IS 'RAW,NORMALIZED,INTERPRETED,ROI';
	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.protocol_id                IS 'protocol_id to get from this file from its prior file(s)';
	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.reporter_list_id           IS 'If a NORMALIZED file, the list of reporter(set)s found in the first column.  Sometimes these are not exactly the same as the expected reporter list form the array design';
	COMMENT ON COLUMN ${projectName}.mARRAY_FILE.reporter_list_as_platform  IS 'convenience.  is the reporter list for this tuple the same as what is expected from the array design';

	CREATE TABLE ${projectName}.mARRAY_FILE_COLUMN ( 
		marray_file_column_id NUMBER(10) NOT NULL,
		marray_run_biospecimen_id NUMBER(10) NOT NULL,
		marray_file_id NUMBER(10) NOT NULL,
		column_number NUMBER(3) NOT NULL,
		column_name VARCHAR2(50) NOT NULL,
		data_values CLOB NULL,  -- for now, NULL
		insert_user VARCHAR(10) NOT NULL,
		insert_date DATE NOT NULL,
		insert_method VARCHAR(20) NOT NULL
	) 
	;

	COMMENT ON TABLE ${projectName}.mARRAY_FILE_COLUMN IS 'Storage of column-by-column microarray data from a file or microarray data, usually normalized data generated by RMA or PLIER.  These matrices are usually dervied via a normalization across many microarrays.  The exact usage of this table is being determined.  At a minimum all but the "data_values" column will be used.  Column data will either be extracted from a flat file (text or binary) or from the "data_values" column where the values are stored comma-separated.  Yes, this is goes against 1st normal form, but if the data are all being used together it is OK.  Also, store each data point individually can not be readily handled by the RDBMS.   
	  A data file/set of normalized data is derived across several microarray runs.  In TCGA-speak, this is Level 2 data.  The resulting file contains columns labled by the biospecimen (and datatype) and rows labeled by the reporter(set).   These data are often used column-by-column to study a particular sample/patient''s molecular profile.  Alternately, they can be analyzed by row to determine a specific genes expression across a patient cohort.';

	COMMENT ON COLUMN ${projectName}.mARRAY_FILE_COLUMN.column_number          IS '1 = first column of sample data.  Not the Reporter row.';

	CREATE TABLE ${projectName}.mARRAY_FILE_ROW
	(
		marray_file_row_id  NUMBER(10) NOT NULL,
		marray_file_id      NUMBER(10) NOT NULL,
		marray_reporter_id  NUMBER(10) NOT NULL,
		row_number          NUMBER(10) NOT NULL,    -- 1 = first row of reported data... not any header data 
		data_values         CLOB NOT NULL,
		insert_user         VARCHAR2(10) NOT NULL,
		insert_date         DATE NOT NULL,
		insert_method       VARCHAR2(20) NOT NULL
	);

	COMMENT ON COLUMN ${projectName}.mARRAY_FILE_ROW.row_number          IS '1 = first row of reported data... not any header data';


	CREATE TABLE ${projectName}.mARRAY_RUN_BIOSPECIMEN
	(
		marray_run_biospecimen_id  NUMBER(10) NOT NULL,
		biospecimen_id             NUMBER(10) NOT NULL,
		marray_run_id              NUMBER(10) NOT NULL
	);



	CREATE TABLE ${projectName}.mARRAY_FILE_PRIOR
	(
		marray_file_id        NUMBER(10) NOT NULL,
		prior_marray_file_id  NUMBER(10) NOT NULL
	);


	CREATE TABLE ${projectName}.mARRAY_RUN
	(
		marray_run_id             NUMBER(10) NOT NULL,
		marray_design_id          NUMBER(3) NOT NULL,
		run_date                  DATE NULL,    --  can we have this? 
		name                      VARCHAR2(50) NOT NULL,    --  Unique name for the hybridization run in the data source 
		image_conversion_file_id  NUMBER(8,2) NULL,    --  FK to the .CEL file, or the like, for the hybridization.  Actual image files will not be stored. 
		insert_user               VARCHAR2(10) NOT NULL,
		insert_date               DATE NOT NULL,
		insert_method             VARCHAR2(20) NOT NULL
	);

	COMMENT ON TABLE ${projectName}.mARRAY_RUN IS 'Info on the microarray run.  For example, a single biotin labeled specimen on an array or a set of cy3/cy5 labeled biospecimens on an array.  Could add a column for the hybridization run information from the instrument.  The image_conversion_file_id references the .CEL file, or the like, which is not store directly in the database.  In TCGA-speak, this is Level 1 data information.';
	COMMENT ON COLUMN ${projectName}.mARRAY_RUN.run_date                  IS 'can we have this?';
	COMMENT ON COLUMN ${projectName}.mARRAY_RUN.name                      IS 'Unique name for the hybridization run in the data source';
	COMMENT ON COLUMN ${projectName}.mARRAY_RUN.image_conversion_file_id  IS 'FK to the .CEL file, or the like, for the hybridization.  Actual image files will not be stored.';

	CREATE TABLE ${projectName}.KM_ATTRIBUTE
	(
		km_attribute_id      NUMBER(10) NOT NULL,
		censor_attribute_id  NUMBER(10) NOT NULL,
		censor_value_id      NUMBER(10) NOT NULL
	)
	;


	--  Create Primary Key Constraints 
	ALTER TABLE ${projectName}.ATTRIBUTE_STATS ADD CONSTRAINT ATT_STATS_PK 
		PRIMARY KEY (attribute_type_id) 
	  ;

	ALTER TABLE ${projectName}.BIOSPECIMEN_ATTRIBUTE_VALUE ADD CONSTRAINT BAV_PK 
		PRIMARY KEY (biospec_attribute_value_id) 
	  ;


	ALTER TABLE ${projectName}.mARRAY_FILE ADD CONSTRAINT mARRAY_FILE_PK 
		PRIMARY KEY (marray_file_id) 
	  ;

	ALTER TABLE ${projectName}.mARRAY_FILE_COLUMN ADD CONSTRAINT mARRAY_FILE_COLUMN_PK 
		PRIMARY KEY (marray_file_column_id) 
	  ;

	ALTER TABLE ${projectName}.mARRAY_FILE_ROW ADD CONSTRAINT mARRAY_FILE_ROW_PK 
		PRIMARY KEY (marray_file_row_id) 
	  ;

	ALTER TABLE ${projectName}.mARRAY_FILE_PRIOR ADD CONSTRAINT mARRAY_FILE_PRIOR_PK 
		PRIMARY KEY (marray_file_id, prior_marray_file_id) 
	  ;

	ALTER TABLE ${projectName}.mARRAY_RUN ADD CONSTRAINT mARRAY_RUN_PK 
		PRIMARY KEY (marray_run_id) 
	  ;

	ALTER TABLE ${projectName}.mARRAY_RUN_BIOSPECIMEN ADD CONSTRAINT mARRAY_RUN_BIOSPECIMEN_PK 
		PRIMARY KEY (marray_run_biospecimen_id) 
	  ;

	ALTER TABLE ${projectName}.KM_ATTRIBUTE ADD CONSTRAINT KM_ATTRIBUTE_PK 
		PRIMARY KEY (km_attribute_id, censor_attribute_id)
	;



	--  Create Indexes 
	ALTER TABLE ${projectName}.ATTRIBUTE_STATS
	ADD CONSTRAINT ATT_STATS_nullable_CC CHECK (nullable in (0,1));

	ALTER TABLE ${projectName}.ATTRIBUTE_STATS
	ADD CONSTRAINT ATT_STATS_single_value_CC CHECK (single_value in (0,1));

	ALTER TABLE ${projectName}.ATTRIBUTE_STATS
	ADD CONSTRAINT ATT_STATS_coverage_CC CHECK (coverage between 0 and 100);

	ALTER TABLE ${projectName}.ATTRIBUTE_STATS
	ADD CONSTRAINT ATT_STATS_u_coverage_CC CHECK (usable_coverage between 0 and 100);

	ALTER TABLE ${projectName}.ATTRIBUTE_STATS
	ADD CONSTRAINT ATT_STATS_table_CC CHECK (table_name in ('PATIENT_ATTRIBUTE_VALUE','BIOSPECIMEN_ATTRIBUTE_VALUE'));

	ALTER TABLE ${projectName}.BIOSPECIMEN_ATTRIBUTE_VALUE
		ADD CONSTRAINT BAV_AK UNIQUE (biospecimen_id, attribute_type_id)
	  ;


	ALTER TABLE ${projectName}.mARRAY_FILE
		ADD CONSTRAINT mARRAY_FILE_name_AK UNIQUE (name)
	  ;

	ALTER TABLE ${projectName}.mARRAY_FILE
	ADD CONSTRAINT mARRAY_FILE_level_CC CHECK (data_level in ('RAW','NORMALIZED','INTERPRETED','ROI'));

	ALTER TABLE ${projectName}.mARRAY_FILE_COLUMN
		ADD CONSTRAINT mARRAY_FILE_COLUMN_AK UNIQUE (marray_run_biospecimen_id, column_number, marray_file_id)
	  ;


	ALTER TABLE ${projectName}.mARRAY_FILE_ROW
		ADD CONSTRAINT mARRAY_FILE_ROW_AK UNIQUE (marray_reporter_id, marray_file_id)
	  ;

	ALTER TABLE ${projectName}.mARRAY_FILE_ROW
		ADD CONSTRAINT mARRAY_FILE_ROW_AK2 UNIQUE (row_number, marray_file_id)
	  ;


	ALTER TABLE ${projectName}.mARRAY_RUN
		ADD CONSTRAINT mARRAY_RUN_name_AK UNIQUE (name)
	  ;

	ALTER TABLE ${projectName}.mARRAY_RUN
		ADD CONSTRAINT mARRAY_RUN_image_AK UNIQUE (image_conversion_file_id)
	  ;

	ALTER TABLE ${projectName}.mARRAY_RUN_BIOSPECIMEN
		ADD CONSTRAINT mARRAY_RUN_BIOSPEC_AK UNIQUE (biospecimen_id, marray_run_id)
	  ;



	--  Create Foreign Key Constraints 
	ALTER TABLE ${projectName}.ATTRIBUTE_STATS ADD CONSTRAINT ATT_STATS_att_type_FK 
		FOREIGN KEY (attribute_type_id) REFERENCES COMMON.ATTRIBUTE_TYPE (attribute_type_id);



	ALTER TABLE ${projectName}.BIOSPECIMEN_ATTRIBUTE_VALUE ADD CONSTRAINT BAV_biospecimen_FK 
		FOREIGN KEY (biospecimen_id) REFERENCES ${projectName}.BIOSPECIMEN (biospecimen_id);

	ALTER TABLE ${projectName}.BIOSPECIMEN_ATTRIBUTE_VALUE ADD CONSTRAINT BAV_attribute_type_FK 
		FOREIGN KEY (attribute_type_id) REFERENCES COMMON.ATTRIBUTE_TYPE (attribute_type_id);

	ALTER TABLE ${projectName}.mARRAY_FILE ADD CONSTRAINT mARRAY_FILE_protocol_FK 
		FOREIGN KEY (protocol_id) REFERENCES COMMON.PROTOCOL (protocol_id);

	ALTER TABLE ${projectName}.mARRAY_FILE ADD CONSTRAINT mARRAY_FILE_rep_list_FK 
		FOREIGN KEY (reporter_list_id) REFERENCES COMMON.REPORTER_LIST (reporter_list_id);

	ALTER TABLE ${projectName}.mARRAY_FILE ADD CONSTRAINT mARRAY_FILE_format_FK 
		FOREIGN KEY (file_format_id) REFERENCES COMMON.FILE_FORMAT (file_format_id);

	ALTER TABLE ${projectName}.mARRAY_FILE ADD CONSTRAINT mARRAY_FILE_type_FK 
		FOREIGN KEY (file_type_id) REFERENCES COMMON.FILE_TYPE (file_type_id);

	ALTER TABLE ${projectName}.mARRAY_FILE_COLUMN ADD CONSTRAINT MFC_run_biospecimen_FK 
	FOREIGN KEY (marray_run_biospecimen_id) REFERENCES ${projectName}.mARRAY_RUN_BIOSPECIMEN (marray_run_biospecimen_id);

	ALTER TABLE ${projectName}.mARRAY_FILE_COLUMN ADD CONSTRAINT MFC_file_FK 
		FOREIGN KEY (marray_file_id) REFERENCES ${projectName}.mARRAY_FILE (marray_file_id);


	ALTER TABLE ${projectName}.mARRAY_FILE_ROW ADD CONSTRAINT MFR_reporter_FK 
		FOREIGN KEY (marray_reporter_id) REFERENCES COMMON.mARRAY_REPORTER (marray_reporter_id);

	ALTER TABLE ${projectName}.mARRAY_FILE_ROW ADD CONSTRAINT MFR_file_FK 
		FOREIGN KEY (marray_file_id) REFERENCES ${projectName}.mARRAY_FILE (marray_file_id);

	ALTER TABLE ${projectName}.mARRAY_FILE_PRIOR ADD CONSTRAINT mARRAY_FILE_PRIOR_child_FK 
		FOREIGN KEY (marray_file_id) REFERENCES ${projectName}.mARRAY_FILE (marray_file_id);

	ALTER TABLE ${projectName}.mARRAY_FILE_PRIOR ADD CONSTRAINT mARRAY_FILE_PRIOR_parent_FK 
		FOREIGN KEY (prior_marray_file_id) REFERENCES ${projectName}.mARRAY_FILE (marray_file_id);

	ALTER TABLE ${projectName}.mARRAY_RUN ADD CONSTRAINT mARRAY_RUN_array_design_FK 
		FOREIGN KEY (marray_design_id) REFERENCES COMMON.mARRAY_DESIGN (marray_design_id);

	ALTER TABLE ${projectName}.mARRAY_RUN ADD CONSTRAINT mARRAY_RUN_file_FK 
		FOREIGN KEY (image_conversion_file_id) REFERENCES ${projectName}.mARRAY_FILE (marray_file_id);

	ALTER TABLE ${projectName}.mARRAY_RUN_BIOSPECIMEN ADD CONSTRAINT MRB_biospecimen_FK 
		FOREIGN KEY (biospecimen_id) REFERENCES ${projectName}.BIOSPECIMEN (biospecimen_id);

	ALTER TABLE ${projectName}.mARRAY_RUN_BIOSPECIMEN ADD CONSTRAINT MRB_marray_run_FK 
		FOREIGN KEY (marray_run_id) REFERENCES ${projectName}.mARRAY_RUN (marray_run_id);

	ALTER TABLE ${projectName}.KM_ATTRIBUTE ADD CONSTRAINT KM_ATTR_censor_attr_FK 
		FOREIGN KEY (censor_attribute_id) REFERENCES COMMON.ATTRIBUTE_TYPE (attribute_type_id)
	;

	ALTER TABLE ${projectName}.KM_ATTRIBUTE ADD CONSTRAINT KM_ATTR_km_attr_FK 
		FOREIGN KEY (km_attribute_id) REFERENCES COMMON.ATTRIBUTE_TYPE (attribute_type_id)
	;

	ALTER TABLE ${projectName}.KM_ATTRIBUTE ADD CONSTRAINT KM_ATTR_censor_vocab_FK 
		FOREIGN KEY (censor_value_id) REFERENCES COMMON.ATTRIBUTE_VOCABULARY (attribute_vocabulary_id)
	;



	-- Indexes


	-- Views
	CREATE OR REPLACE VIEW ${projectName}.KM_Attributes
	as
	select k.long_name KM_ATTRIBUTE, k.short_name KM_ATTRIBUTE_SHORT, c.long_name CENSOR_ATTRIBUTE, c.short_name CENSOR_ATTRIBUTE_SHORT , v.term CENSOR_VALUE
	from ${projectName}.km_attribute km, COMMON.attribute_type k, COMMON.attribute_type c, COMMON.attribute_vocabulary v
	where km.km_attribute_id = k.attribute_type_id
	and km.censor_attribute_id = c.attribute_type_id
	and km.censor_value_id = v.attribute_vocabulary_id
	WITH READ ONLY;


	CREATE OR REPLACE VIEW ${projectName}.PLIER_CONTENTS
	as
	select rownum id, f.name plier_name, b.name biospecimen_name
	from ${projectName}.marray_file_prior p,
	     ${projectName}.marray_file f,
	     ${projectName}.marray_file_column c,
	     ${projectName}.marray_run_biospecimen r,
	     ${projectName}.biospecimen b
	where c.marray_file_id = P.PRIOR_MARRAY_FILE_ID
	and P.MARRAY_FILE_ID = F.MARRAY_FILE_ID
	and c.marray_run_biospecimen_id = r.marray_run_biospecimen_id
	and r.biospecimen_id = b.biospecimen_id
	and f.file_type_id = 101
	and f.file_format_id = 101
	WITH READ ONLY;


commit;
